{"title":"JS面向对象基本知识","slug":"JS面向对象基本知识","date":"2016-07-15T16:21:44.000Z","updated":"2017-06-29T01:14:13.564Z","comments":true,"excerpt":"<p>学习 <code>Javascript</code>，最难的地方是什么？个人觉得 就是<code>面对对象</code>这一块。对于初学者来说是<code>极为不友好</code>的一种 <code>编程思维方式</code>。这一篇博文我们讨论 <code>“封装”</code>，并会在之后再介绍学习<code>“继承”</code><br>首先确认一个概念，<code>“万物皆是对象”</code>，具有<code>“属性”</code>或者<code>“方法”</code>亦或者都具备。</p>","content":"<p>学习 <code>Javascript</code>，最难的地方是什么？个人觉得 就是<code>面对对象</code>这一块。对于初学者来说是<code>极为不友好</code>的一种 <code>编程思维方式</code>。这一篇博文我们讨论 <code>“封装”</code>，并会在之后再介绍学习<code>“继承”</code><br>首先确认一个概念，<code>“万物皆是对象”</code>，具有<code>“属性”</code>或者<code>“方法”</code>亦或者都具备。</p>\n<a id=\"more\"></a>\n<h3 id=\"原始模式\"><a href=\"#原始模式\" class=\"headerlink\" title=\"原始模式\"></a>原始模式</h3><p>但是在原始的设计模式下，根据对象的属性进行简单的封装，常常遇到类似的问题：</p>\n<p>如果需要生成多个实例的时候，就会发生代码冗余，不能找出存在的基本关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var car1 = &#123;&#125;</div><div class=\"line\">    car1.brand : &quot;BMW&quot;,</div><div class=\"line\">    car1.color : &quot;red&quot;,</div><div class=\"line\">    car1.speed : &quot;500KM/h&quot;</div><div class=\"line\">var car2 = &#123;&#125;</div><div class=\"line\">    car2.brand : &quot;Audi&quot;,</div><div class=\"line\">    car2.color : &quot;grey&quot;,</div><div class=\"line\">    car2.speed : &quot;400KM/h&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"原始模式的改进\"><a href=\"#原始模式的改进\" class=\"headerlink\" title=\"原始模式的改进\"></a>原始模式的改进</h3><p>就上面的问题，改进后的代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function car(band,color,speed)&#123;</div><div class=\"line\">    ruturn brand:brand,</div><div class=\"line\">        color:color,</div><div class=\"line\">        speed:speed</div><div class=\"line\">&#125;</div><div class=\"line\">var car1 = new car(&quot;BMW&quot;,red,&quot;500KM/h&quot;)</div><div class=\"line\">var car2 = new car(&quot;Audi&quot;,grey,&quot;400KM/h&quot;)</div></pre></td></tr></table></figure>\n<p>不过两者之间没有内在联系，依然不是同一个原型对象的实例。</p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function car(brand,color,speed)&#123;</div><div class=\"line\">    this.brand=brand;</div><div class=\"line\">    this.color=color;</div><div class=\"line\">    this.speed=speed</div><div class=\"line\">&#125;</div><div class=\"line\">var car1 = new car(&quot;BMW&quot;,red,&quot;500KM/h&quot;)</div><div class=\"line\">var car2 = new car(&quot;Audi&quot;,grey,&quot;400KM/h&quot;)</div><div class=\"line\">alert(car1.brand)</div><div class=\"line\">alert(car2.speed)</div></pre></td></tr></table></figure>\n<p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(car1.constructor == rar); //true</div><div class=\"line\">alert(car2.constructor == rar); //true</div></pre></td></tr></table></figure>\n<p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(car1 instanceof car); //true</div><div class=\"line\">alert(car2 instanceof car); //true</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数模式的问题\"><a href=\"#构造函数模式的问题\" class=\"headerlink\" title=\"构造函数模式的问题\"></a>构造函数模式的问题</h3><p>构造函数方法很好用，但是存在一个浪费内存的问题。<br>接下来，我们给他新增不变的属性 “Convertible”（敞篷汽车），再加上一个方法 drive（驾驶）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function car(brand,color,speed)&#123;</div><div class=\"line\">    this.brand=brand;</div><div class=\"line\">    this.color=color;</div><div class=\"line\">    this.speed=speed;</div><div class=\"line\">    this.Convertible=true;</div><div class=\"line\">    this.drive=function()&#123;</div><div class=\"line\">        alert(&quot;炒鸡快呢&quot;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var car1 = new car(&quot;BMW&quot;,red,&quot;500KM/h&quot;)</div><div class=\"line\">var car2 = new car(&quot;Audi&quot;,grey,&quot;400KM/h&quot;)</div><div class=\"line\">alert(car1.Convertible)//是敞篷</div><div class=\"line\">car2.drive()//开得快</div></pre></td></tr></table></figure>\n<p>表面看似没啥问题，实际上有大问题，对于每个对象而言，每次生成实例，都会生成多于的内容，浪费内存。会影响性能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(car1.Convertible == car2.Convertible);//false</div></pre></td></tr></table></figure>\n<p>为了解决上述问题，我们有了Prototype（原型链）模式</p>\n<h3 id=\"Prototype模式\"><a href=\"#Prototype模式\" class=\"headerlink\" title=\"Prototype模式\"></a>Prototype模式</h3><p>每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br>这意味着，我们可以把那些不变的属性和方法，直接定义在prototype对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Car(brand,color)&#123;</div><div class=\"line\">    this.brand = brand;</div><div class=\"line\">    this.color = color;</div><div class=\"line\">&#125;</div><div class=\"line\">car.prototype.Convertible=true;</div><div class=\"line\">car.prototype.drive=function()&#123;</div><div class=\"line\">    alert(&quot;炒鸡快呢&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"这时所有实例的Convertible属性和drive-方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\"><a href=\"#这时所有实例的Convertible属性和drive-方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\" class=\"headerlink\" title=\"这时所有实例的Convertible属性和drive()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。\"></a>这时所有实例的Convertible属性和drive()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</h5><h3 id=\"Prototype模式的验证方法\"><a href=\"#Prototype模式的验证方法\" class=\"headerlink\" title=\"Prototype模式的验证方法\"></a>Prototype模式的验证方法</h3><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。，</p>\n<h4 id=\"isPrototypeOf-NaN\"><a href=\"#isPrototypeOf-NaN\" class=\"headerlink\" title=\"isPrototypeOf()\"></a>isPrototypeOf()</h4><p>这个方法用来判断，某个proptotype对象和某个实例之间的关系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(Car.prototype.isPrototypeOf(car1)); //true</div><div class=\"line\">alert(Car.prototype.isPrototypeOf(car2)); //true</div></pre></td></tr></table></figure>\n<h4 id=\"hasOwnProperty-NaN\"><a href=\"#hasOwnProperty-NaN\" class=\"headerlink\" title=\"hasOwnProperty()\"></a>hasOwnProperty()</h4><p>每个实例对象都有一个hasOwnProperty()方法，用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(car1.hasOwnProperty(&quot;name&quot;)); // true</div><div class=\"line\">alert(car1.hasOwnProperty(&quot;Convertible&quot;)); // false</div></pre></td></tr></table></figure>\n<h4 id=\"in运算符\"><a href=\"#in运算符\" class=\"headerlink\" title=\"in运算符\"></a>in运算符</h4><ul>\n<li><p>in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">alert(&quot;name&quot; in car1); // true</div><div class=\"line\">alert(&quot;Convertible&quot; in car1); // true</div></pre></td></tr></table></figure>\n</li>\n<li><p>in运算符还可以用来遍历某个对象的所有属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var prop in car1) &#123; alert(&quot;car1[&quot;+prop+&quot;]=&quot;+car1[prop]); &#125;</div></pre></td></tr></table></figure></li>\n</ul>\n","categories":[],"tags":[{"name":"js","path":"api/tags/js.json"}]}