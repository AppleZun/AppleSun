{"title":"JSONP的实现","slug":"JSONP的实现","date":"2016-10-03T01:10:48.000Z","updated":"2017-06-29T01:14:13.564Z","comments":true,"excerpt":"<p>JSONP 是<code>解决跨域问题</code>的一种方案，不同于 JSON，其并不是一种数据交换格式，而只是一种绕过跨域的技巧</p>\n<h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>JSONP 的原理非常简单，为了克服跨域问题，<strong>利用没有跨域限制的 script 标签加载预设的 callback 将内容传递给 js</strong>。一般来说我们约定通过一个参数来告诉服务器 JSONP 返回时应该调用的回调函数名，然后拼接出对应的 js。已微博 API 为例，这个参数名是 _cb。</p>","content":"<p>JSONP 是<code>解决跨域问题</code>的一种方案，不同于 JSON，其并不是一种数据交换格式，而只是一种绕过跨域的技巧</p>\n<h3 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h3><p>JSONP 的原理非常简单，为了克服跨域问题，<strong>利用没有跨域限制的 script 标签加载预设的 callback 将内容传递给 js</strong>。一般来说我们约定通过一个参数来告诉服务器 JSONP 返回时应该调用的回调函数名，然后拼接出对应的 js。已微博 API 为例，这个参数名是 _cb。</p>\n<a id=\"more\"></a>\n<p><img src=\"http://7xjdah.com1.z0.glb.clouddn.com/pic2016080814.png\" alt=\"img\"></p>\n<p>写一个简单的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function JSONP(url,params,callbackKey,callbackFn)&#123;</div><div class=\"line\">\t//在参数里限定 callback 的名字</div><div class=\"line\">\tparams = params || &#123;&#125;</div><div class=\"line\">\tparams[callbackKey] = &quot;jsonpCallback&quot;</div><div class=\"line\">\t//预留callbackFn</div><div class=\"line\">\twindow.jsonpCallback = callbackFn</div><div class=\"line\">\tconst paramKeys = Object.keys(params)</div><div class=\"line\">\tconst paramString = paramKeys</div><div class=\"line\">\t.map(key =&gt; `$&#123;key&#125;=$&#123;params[key]&#125;`)</div><div class=\"line\">\t.join(&apos;&amp;&apos;)</div><div class=\"line\">\t//插入 DOM 元素</div><div class=\"line\">\tconst script = document.createElement(&apos;script&apos;)</div><div class=\"line\">\tscript.setAttribute(&apos;src&apos;,`$&#123;url&#125;?$&#123;paraString&#125;`)</div><div class=\"line\">\tdocument.body.appendChild(script)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>For Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSONP(&#123;</div><div class=\"line\">\turl: &apos;http://s.weibo.com/ajax/jsonp/suggestion&apos;,</div><div class=\"line\">\tparams: &#123;</div><div class=\"line\">\t\tkey: &apos;test&apos;,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tcallback(result)&#123;</div><div class=\"line\">\t\tconsole.log(result.data)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>会在命令行看到 <code>[&quot;TEST&quot;, &quot;特殊泰帮承&quot;]</code>，注意这里新浪微博的 API 只支持 HTTP，所以我们只能在 HTTP 页面上测试。</p>\n<h3 id=\"同时进行多个请求\"><a href=\"#同时进行多个请求\" class=\"headerlink\" title=\"同时进行多个请求\"></a>同时进行多个请求</h3><p>上面的流程有一个问题，就是在只有一个 JSONP 调用时它工作的很正常，但是<code>当出现两个或者以上的请求，回调函数就会被覆盖</code>，这样会出现混乱。为了解决这个问题，我们需要<code>对所有的回调函数进行编码</code>，并且<code>在调用时告诉后端对应的独一无二的编号</code>。</p>\n<p>除此之外，<code>污染全局空间</code>显然是个不明智的选择，这个问题解决起来倒是非常简单，扔到 <a href=\"http://jsonp.xxx/\" target=\"_blank\" rel=\"external\">http://JSONP.xxx</a> 下即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">function JSONP(&#123;  </div><div class=\"line\">  url,</div><div class=\"line\">  params,</div><div class=\"line\">  callbackKey,</div><div class=\"line\">  callback</div><div class=\"line\">&#125;) &#123;</div><div class=\"line\">  // 唯一 id，不存在则初始化</div><div class=\"line\">  JSONP.callbackId = JSONP.callbackId || 1</div><div class=\"line\">  params = params || &#123;&#125;</div><div class=\"line\">    // 传递的 callback 名，和下面预留的一致</div><div class=\"line\">  params[callbackKey] = `JSONP.callbacks[$&#123;JSONP.callbackId&#125;]`</div><div class=\"line\">    // 不要污染 window</div><div class=\"line\">  JSONP.callbacks = JSONP.callbacks || []</div><div class=\"line\">    // 按照 id 放置 callback</div><div class=\"line\">  JSONP.callbacks[JSONP.callbackId] = callback</div><div class=\"line\">  const paramKeys = Object.keys(params)</div><div class=\"line\">  const paramString = paramKeys</div><div class=\"line\">    .map(key =&gt; `$&#123;key&#125;=$&#123;params[key]&#125;`)</div><div class=\"line\">    .join(&apos;&amp;&apos;)</div><div class=\"line\">  const script = document.createElement(&apos;script&apos;)</div><div class=\"line\">  script.setAttribute(&apos;src&apos;, `$&#123;url&#125;?$&#123;paramString&#125;`)</div><div class=\"line\">  document.body.appendChild(script)</div><div class=\"line\">    // id 占用，自增</div><div class=\"line\">  JSONP.callbackId++</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">JSONP(&#123;  </div><div class=\"line\">  url: &apos;http://s.weibo.com/ajax/jsonp/suggestion&apos;,</div><div class=\"line\">  params: &#123;</div><div class=\"line\">    key: &apos;test&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  callbackKey: &apos;_cb&apos;,</div><div class=\"line\">  callback(result) &#123;</div><div class=\"line\">    console.log(result.data)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">JSONP(&#123;  </div><div class=\"line\">  url: &apos;http://s.weibo.com/ajax/jsonp/suggestion&apos;,</div><div class=\"line\">  params: &#123;</div><div class=\"line\">    key: &apos;excited&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  callbackKey: &apos;_cb&apos;,</div><div class=\"line\">  callback(result) &#123;</div><div class=\"line\">    console.log(result.data)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>可以看到现在请求的都是 <a href=\"http://s.weibo.com/ajax/jsonp/suggestion?key=test&amp;_cb=JSONP.callbacks\" target=\"_blank\" rel=\"external\">http://s.weibo.com/ajax/jsonp/suggestion?key=test&amp;_cb=JSONP.callbacks[1] </a>这样的，然后得到的 js 也是 JSONP.callbacks<a href=\"http://crackerme.github.io/2016/10/03/JSONP%E7%9A%84%E5%AE%9E%E7%8E%B0-%E8%BD%AC/\" target=\"_blank\" rel=\"external\">1</a>，这样就不会有冲突的问题，也不污染全局域。</p>\n<h3 id=\"URI编码\"><a href=\"#URI编码\" class=\"headerlink\" title=\"URI编码\"></a>URI编码</h3><p>上面的代码仍然存在一个小问题，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">JSONP(&#123;  </div><div class=\"line\">  url: &apos;http://s.weibo.com/ajax/jsonp/suggestion&apos;,</div><div class=\"line\">  params: &#123;</div><div class=\"line\">    a: &apos;545&amp;b=3&apos;</div><div class=\"line\">    b: &apos;5&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  callbackKey: &apos;_cb&apos;,</div><div class=\"line\">  callback(result) &#123;</div><div class=\"line\">    console.log(result.data)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>会导致 a 的内容直接被拼写进字符串，导致覆盖了 b 的值，而用户真的只是想让 a 的值为 trdgd&amp;b=2 而已。解决方案也简单，进行 URI 编码即可，encodeURIComponent(‘trdgd&amp;b=2’) 的结果为 trdgd%26b%3D2。即将上面参数处理的部分改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const paramString = paramKeys  </div><div class=\"line\">  .map(key =&gt; `$&#123;key&#125;=$&#123;encodeURIComponent(params[key])&#125;`)</div><div class=\"line\">  .join(&apos;&amp;&apos;)</div></pre></td></tr></table></figure>\n<p>这里值得一提的是，由于最终的 URL 不能包含 ASCII 码以外的字符，所以其实当使用中文或者特殊字符时其实会被自动编码。而 +，空格，/，?，%，#，&amp;，= 等字符在 URL 中则会出现歧义，只有手动编码后才能让服务器端正确解析。</p>\n<p><strong>转自知乎源链接</strong></p>\n","categories":[],"tags":[{"name":"js","path":"api/tags/js.json"}]}